---
layout:     post
title:      XML文件的解析
subtitle:   DOM/SAX/JDOM/DOM4J
date:       2020-06-12
author:     Claire
header-img: img/post-bg-universe.jpg
catalog: true
tags:
    - XML
    - DOM
    - SAX
    - DOM4J
    - JAVA
---

# XML文件的解析

> mybatis的学习当中，配置的加载传统的是通过解析用户配置的文件，获取到数据库连接与对象实体映射关系的，书中有描述到DOM\SAX\StAX 几种方案，一方面是夯实基础，一方面是了解三种方法的优缺点，今天就学习一下XML文件的解析

## 一、XML的解析方式

- DOM  解析XML底层接口之一,跨平台，跨语言
- SAX 解析XML底层接口之一
- Jdom/dom4J  基于底层API的封装，Java语言，更方便便捷

## 二、DOM解析

> DOM 解析的原理：树形结构，依赖内存加载文件，树在内存中持久化存储，映射成Document对象，解析DOM树，识别父节点、当前节点、兄弟节点和子节点，在节点间游历，就能够获取到整棵树的数据。操作简易，消耗大，适用于小文档或者需要频繁修改文档的场景。

### 使用JDK自带的DocumentBuilderFactory进行解析

```java
//生成工厂实例
  DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();
//创建builder实例
        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();
        //读取文件内容，加载入Document对象
        Document document = documentBuilder.parse("store.xml");
        //根据Name获取节点
        NodeList productList = document.getElementsByTagName("product");
       for(int i =0;i<productList.getLength();i++){
           Node product = productList.item(i);
           Node firstChild = product.getFirstChild();
           Node lastChild = product.getLastChild();
           String nodeName = product.getNodeName();
           short nodeType = product.getNodeType();
           String nodeValue = product.getNodeValue();
           //获取节点内容
           NamedNodeMap namedNodeMap = product.getAttributes();
           for(int j=0;j<namedNodeMap.getLength();j++){
               Node node = namedNodeMap.item(j);
               String name = node.getNodeName();
               String value = node.getNodeValue();
               short type = node.getNodeType();
               System.out.println("name:"+name+";value:"+value);
           }
           //获取子节点内容
           NodeList childNodes = product.getChildNodes();
           for(int k =0 ;k<childNodes.getLength();k++){
               Node item = childNodes.item(k);
               String itemNodeName = item.getNodeName();
               short itemNodeType = item.getNodeType();
               String itemNodeValue = item.getNodeValue();
               System.out.println("itemName:"+itemNodeName+";itemValue:"+itemNodeValue);

               NodeList children = item.getChildNodes();
               for(int m =0;m<children.getLength();m++){
                   Node item1 = children.item(m);
                   System.out.println("itemName:"+item1.getNodeName()+";itemValue:"+item1.getNodeValue());
               }
           }
       }
```

## 三、SAX解析

> SAX解析原理：基于事件的模型，不需要将全部文档加载入内存，只需要用户读取的时候加载相应的内容片段即可，响应快，消耗小，适用于大型文档读取的场景。

### 使用JDK自带的SAXParserFactory

- 创建一个用于解析的Handler, 重写父类的关于片段解析的代码

```java
public class SaxHandler extends DefaultHandler {
    private List<Product> products = null;
    private Product product;
    private String currentTag = null;
    private String currentValue = null;
    private String nodeName = null;

    public SaxHandler(String nodeName) {
        this.nodeName = nodeName;
    }

    public List<Product> getProducts() {
        return products;
    }


    @Override
    public void startDocument() throws SAXException {
        // 读到一个开始标签会触发
        super.startDocument();

        products = new ArrayList<Product>();
    }

    @Override
    public void endDocument() throws SAXException {
        //自动生成的方法存根
        super.endDocument();
    }

    @Override
    public void startElement(String uri, String localName, String name,
                             Attributes attributes) throws SAXException {
        //文档的开头调用
        super.startElement(uri, localName, name, attributes);

        if (name.equals(nodeName)) {
            product = new Product();
        }
        if (attributes != null && product != null) {
            for (int i = 0; i < attributes.getLength(); i++) {
                if (attributes.getQName(i).equals("id")) {
                    product.setId(Integer.valueOf(attributes.getValue(i)));
                }
            }
        }
        currentTag = name;
    }

    @Override
    public void characters(char[] ch, int start, int length)
            throws SAXException {
        //处理在XML文件中读到的内容
        super.characters(ch, start, length);

        if (currentTag != null && product != null) {
            currentValue = new String(ch, start, length);
            if (!currentValue.trim().equals("") && !currentValue.trim().equals("\n")) {
                if (currentTag.equals("name")) {
                    product.setName(currentValue);
                } else if (currentTag.equals("price")) {
                    product.setPrice(Double.valueOf(currentValue));
                }else if(currentTag.equals("inventory")){
                    product.setInventory(Integer.valueOf(currentValue));
                }
            }
        }
        currentTag = null;
        currentValue = null;
    }

    @Override
    public void endElement(String uri, String localName, String name)
            throws SAXException {
        // 结束标签的时候调用
        super.endElement(uri, localName, name);

        if (name.equals(nodeName)) {
            products.add(product);
        }
    }

}
```

- 创建一个用于接收的对象（别的数据结构也可）

```java
public class Product {
    private Integer id;
    private String name;
    private Double price;
    private Integer inventory;

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Double getPrice() {
        return price;
    }

    public void setPrice(Double price) {
        this.price = price;
    }

    public Integer getInventory() {
        return inventory;
    }

    public void setInventory(Integer inventory) {
        this.inventory = inventory;
    }

    @Override
    public String toString() {
        return "Product{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", price=" + price +
                ", inventory=" + inventory +
                '}';
    }
}
```

- 读取文件，并使用Handler进行解析

```java
       SAXParserFactory saxParserFactory = SAXParserFactory.newInstance();
        SAXParser saxParser = saxParserFactory.newSAXParser();
        SaxHandler saxHandler = new SaxHandler("product");
        saxParser.parse(new InputSource("store.xml"), saxHandler);
        List<Product> products = saxHandler.getProducts();
        products.forEach(System.out::println);
```

## 四、JDOM/Dom4J

- JDOM的目的是成为Java特定文档模型，它简化与XML的交互并且比使用DOM实现更快

- Dom4J，是JDOM 的一种智能分支，合并了许多超出基本 XML 文档表示的功能

- 以下为Dom4j为例
- 添加maven依赖

```java
       <dependency>
            <groupId>dom4j</groupId>
            <artifactId>dom4j</artifactId>
            <version>1.6.1</version>
        </dependency>
```

- 读取xml文件

```java
        SAXReader saxReader = new SAXReader();
        Document document = saxReader.read(new File("store.xml"));
```

- 处理解析逻辑

```java
        Element rootElement = document.getRootElement();
        List<Element> elements = rootElement.elements();
        List<Product> products = new ArrayList<>();
        for(Element element : elements){
            Integer id = Integer.valueOf(element.attributeValue("id"));
            String name = element.element("name").getText();
            Double price = Double.valueOf(element.element("price").getText());
            Integer inventory = Integer.valueOf(element.elementText("inventory"));
            Product product = new Product();
            product.setId(id);
            product.setName(name);
            product.setPrice(price);
            product.setInventory(inventory);
            
            products.add(product);
        }
        products.forEach(System.out::println);
```

> All codes are here：[this page](https://github.com/CzyerChen/recording/blob/master/basicjava/src/main/java/com.basic/dom/DomBaseMain.java)